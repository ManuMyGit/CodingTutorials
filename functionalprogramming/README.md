# Basic definitions  
- In imperative programming we develop programs where classes are the most important structures.
- In functional programming we develop programs where functions are the most important structures.
- In OOP we have:
   - Classes.
   - Encapsulation (method visibility, attributes, ...).
   - Composition.
   - Inheritance.
   - Polymorphism (ability of functions, arrays, ... of accepting objects of a certain class and its children).
- In functional programming we have:
   - Pure functions: functions that only take certain parameters and return a value. It should return a value based only on the arguments and should have no side effects.
   - Higher order functions: functions that accept or return functions as parameters.
   - Immutability: objects accepted by functions can't be modified, they are immutable. Immutability is one of the core principles of functional programming, and it refers to the property that an entity can't be modified after being instantiated. Java itself provides several built-in immutable types, for instance, String. This is primarily for security reasons, as we heavily use String in class loading and as keys in hash-based data structures. There are several other built-in immutable types like primitive wrappers and math types. 
   - Recursive functions.
   - Lazy evaluation.
- Why is functional programming important?
   - Because it focuses on purely mathematical concepts and because of its immutability there isn't any collateral damage.
   - Concurrency is more important than ever: now all devices are multi-core so atomic execution (with no collateral damage) can take advantage of all available resources.
   - Scala is the best example.
- What are functional interfaces?
   - Sometimes we need configure the behavior of a method in runtime. Everyone has ever used Comparator to indicate how a comparison must work, or Runnable to define how a code must execute.
   - They are interfaces that only exist to wrap a simple method.
- What are anonymous classes?
   - It is a class with no name, which is defined in the same code where object of the class is created.
  
# Lambdas  
- Anonymous class creation has a lot of redundant information. It can be observed in the following example:  
`public void foo(List<Person> users){`
`Collection.sort(users, new Comparator<Person>()) {`
`@Override`
`public int compare(Person one, Person two) {`
`return one.getLastName().compareTo(two.getLastName()));`
`}`
- In the previous method we can see that the compare method is redundant to define parameters type, we are comparing obviously people. Return is also redundant because we must return something. Even ";", "{", "}" are redundant.  
- Lambda expressions are a way to create anonymous methods in a much simpler way.  
- Lambdas can be used wherever you can use a anonymous class (such as the previous Comparator).  
- They are basically anonymous functions.  
- The previous example would be like that:  
`public void foo(List<Person> users) {`
`sort(users, (one, two) -> one.getLastName().compareTo(two.getLastName()));`
`}`
- Bytecode generated by a lambda expression is not equivalent to the one generated for an anonymous class. For lambdas, compiler uses invoke_dynamic which has, among other things, better performance  
- A lambda is not the same as a closure.  
- They are really important because it makes easier to use higher order methods.  
- What other thing can we do with methods that accept functions as parameters? Monads.  
- A lambda expression can be used to create an instance of a functional interface.  
- The type of the functional interface is deduced according to the context and it works both assignment contexts and method invocations (parameters).  
- Compiler deduces the type of the lambda expression parameters based on functional interface abstract method definition, so there is no need to write its type.  
- To deduce a lambda expression type:  
   - Context identification: assignment or method invocation.  
   - To identify target type: variable or parameter.  
   - To identify functional interface of the target type.  
   - To identify the descriptor of the function.   
   - To verify that function descriptor is coherent with lambda expression.  
   - There are two special cases:  
      - The same lambda expression can suit different function descriptors, I mean, different functional interfaces.  
      - Compatibility rule for not return. If a lambda expression is made by a sentence, then is compatible with descriptors of functions which don't have any return, I mean, void.  
- Lambda expressions can use variables or parameters defined like constants (final) of really constants (a variable or parameter really constant is the one which is assigned just once, even if it hasn't been defined using final).  
- In contrast to anonymous classes, in lambdas "this" refers to the class instance where lambda expression has been written.  
`class SessionManager{`
`long before = ...;`
`void expire(File root) {`
`root.listFiles(File p -> checkExpiry(p.lastModified(), this.before));`
`}`
`boolean checkExpiry(long time, long expiry) {...}`
`}`
- In the previous example, if before had been modified in any other way of the class, a compilation error would be launched by previous definition of "really constant".   
  
# Lambdas structure  
- Parameters are separated of the function body by "->".
- Parameters are separated by "," and between "(" and ")" (optional when there is only one parameter).
- Parameter type can be omitted when there is enough information for the compiler to deduce it.
- If the function body is complex (it has more than one line) it must be between "{" and "}", to have ";" and to have a "return".
- If the function body is simple you can omit "{", "}", ";" and "return".
- If the lambda expression only calls a unique method we can use a reference to a method. The reference methods are the invocation of methods by its name. Lambda expressions compacter and easier to read:
   - To refer to a static class method: Class:staticMethodName
   - To refer to an object method: Object::instanceMethodName
   - To refer to an arbitrary object method of a concrete type: Type::methodName
   - To refer to a constructor: Class:new
- Examples:
   - General:
`Person {`
`String name;`
`LocalDate birthday;`
`//getters ... setters ...`
`public static int compareByAge(Person a, Person b) {`
`  return a.birthday.compareTo(b.birthday);`
`}`
`}`
  - Static class method:
`Person[] personArray = new Person[1000];`
`...`
`//Order an array using lambdas`
`Arrays.sort(personArray, (a, b) -> Person.compareByAge(a, b));`
`//Order an array using reference methods`
`Arrays.sort(personArray, Person::compareByAge);`
  - Instance method:
`Person[] personArray = new Person[1000];`
`...`
`ComparisonProvider comparisonProvider = new ComparisonProvider();`
`//Order an array using lambdas`
`Arrays.sort(personArray, (a, b) -> comparisonProvider.compareByAge(a, b));`
`//Order an array using reference methods`
`Arrays.sort(personArray, comparisonProvider::compareByAge);`
  - Type method:
`String[] strings = {"asdf", "asdfas", ...};`
`//Order an array using lambdas`
`Arrays.sort(strings, (a, b) -> a.compareToIgnoreCase(b));`
`//Order an array using reference methods`
`Arrays.sort(strings, String::compareToIgnoreCase);`
  - Constructor (with no parameters):
`//Create a person using lambdas`
`Supplier<Persona> s1 = () -> new Persona();`
`Persona p1 = s1.get();`
`//Create a person using reference methods`
`Supplier<Persona> s1 = Persona::new;`
Persona p1 = s1.get();
  - Constructor (with parameters):  
`//Create a person using lambdas`
`Function<String, Persona> f1 = (w) -> new Persona(w);`
`Persona p1 = f1.apply("Manu");`
`//Create a person using reference methods`
`Function<String, Persona> f1 = Persona::new;`
`Persona p1 = f1.apply("Manu");`
  
# Predicates  
- A predicate is a functional interface which defines a condition that and object must accomplish.  
- The predicate has a unique method named test which accepts the object and check the condition.  
- The execution code is always the same. You only need to implement the predicate (see example).  
- The problem is that the more conditions, the more classes to maintain.  
- It is extremely easy to implement strategy pattern with predicates.  
- There is a lot of duplicate code when using predicates.  
  
# Monads  
- How much do you hate NullPointerException?  
- Monads are parametrized types.  
- They can wrap a value in a computational context.  
- They have a method that from a <T> value can create a Monad<T>.  
- They have binding method that from a function from U to T can transform `Monad<T>` into `Monad<U>`.  
- There are other methods like bind, that can change the value but not the computational context, so they are safe.  
  
# Optional  
- An Optional is a Monad.  
- It expresses the possible absence of a data type (there is no need of null).
- It is the Null Object patter for the T type.
- An Optional is empty when there is no value inside (it can be null).
- Its methods allow to operate with the value in a safe way. If you try an operation with an empty Optional, it will return an empty value without launching an exception.
- Traditional example:
`if(computer != null) {`
`SoundCard soundCard = computer.getSoundCard();`
`if(soundCard != null) {`
`USB usb = soundCard.getUSB();`
`if(usb != null) {`
`name = usb.getVersion();`
`}`
`}`
`}`
- Optional example:  
`String name = Optional.of(computer) //Optional<Computer>`
`.flatMap(Computer::getSoundCard) //Optional<SoundCard>`
`.flatMap(SoundCard::getUSB) //Optional<USB> returns a String, we use map.`
`.orElse("UNKNOW"); //String`
  
# Map vs FlatMap  
- FlatMap always returns an Object wrapped in an Optional.  
- Map returns the object.  
- FlatMap also makes the object simpler, what ensures that instead of returning `Optional<Optionanl<T>>`, it returns `Optional<T>`.  Basically, flatMap() = map() + Flattening.
- Map example:  
`List<String> listOfIntegers = Arrays.asList(1, 2, 3, 4, 5);`
`List<Integer> listOfIntegersByTwo = listOfIntegers.stream()`
`.map(a -> a * 2).collect(Collectors.toList());`
- FlatMap example:  
`List<Integer> list1 = Arrays.asList(1,2,3);`
`List<Integer> list2 = Arrays.asList(4,5,6);`
`List<Integer> list3 = Arrays.asList(7,8,9);`
`List<List<Integer>> listOfLists = Arrays.asList(list1, list2, list3);`
`List<Integer> listOfAllIntegers = listOfLists.stream()`
`.flatMap(x -> x.stream())`
`.collect(Collectors.toList());`
  
# Streams  
- A stream is NOT a collection of elements (its content can not be saved in any place).
- A stream is NOT a sequence (the order can be or not important).
- A stream is an abstraction that represents zero or more values (a value means an immutable object, which is extremely important to concurrency).
- Immutability is essential in functional programming.
- A stream is like a strengthened iterator.
- Streams make pretty pipeline concept. A pipeline is a sequence of zero or more intermediate operations and a final operation with a stream.
- Pipelines are lazy: job is made just when a final operation is found. If there isn't a final operation, the stream do nothing.
- It exists some primitive streams: DoubleStream, IntStream and LongStream (it prevent from using Autoboxing and Unboxing).
- Streams use Filter pattern --> Map (to map to other type) --> Reduce (return a unique value).  
- Stream example:
`public long calculateDebt(List<User> users) {`
`return users.stream()`
`.filter(u -> u.getMemberShip().equals('PREMIUM'))`
`.filter(u -> u.getDebt() > 0)`
`.sorted((one, two) -> (int)(one.getDebt() > two.getDebt()))`
`.limit(50)`
`.map(User::getDebt)`
`.reduce(0, (subtotal, elemennt) -> subtotal + element);`
`}`
- Another example:  
`public long calculateDebt(List<User> users) {`
`return users.stream()`
`.filter(u -> u.getMemberShip().equals('PREMIUM'))`
`.filter(u -> u.getDebt() > 0)`
`.sorted(Comparator.comparingLong(User::getDebt))`
`.limit(50)`
`.mapToLong(User::getDebt)`
`.sum();`
`}`
- Parallel operation:  
`public long calculateDebt(List<User> users) {`
`return users.parallelStream()`
`.filter(u -> u.getMemberShip() == PREMIUM)`
`.filter(u -> u.getDebt() > 0)`
`.sorted(Comparator.comparingLong(User::getDebt))`
`.limit(50)`
`.mapToLong(User::getDebt)`
`.sum();`
`}`
- Parallel operations should be used when the output of the operation is not needed to be dependent on the order of elements present in source collection.
  
# Stream methods  
- Basic methods:  
   - `Stream.of(T): Stream<T>` --> returns a sequential Stream containing a single element.
   - `Stream.empty(): Stream` --> Returns an empty stream.
   - `Arrays.stream(T[]): Stream<T>` --> Returns a stream of the array given as a parameter. Primitive version returns DoubleStream, IntStream, LongStream.
   - `Collection<E>.stream(): Stream<E>` --> Returns a stream of the elements of the collection. Parallel version: `Collection<E>.parallelStream(): Stream<E>`.
   - `Stream.iterate(T, UnaryOperation<T>): Stream<T>` --> Returns an infinite stream, ordered and sequential, from the initial value T and from applying the UnaryOperator function to the initial value to get the other elements. To limit its size, the method `+limit(long): Stream` can be used.
   - `Stream.generate(Supplier<T>): Stream<T>` --> returns and infinite stream, sequential but not ordered, from a lambda expression provided by the supplier.

- Filter methods:
   - `filter(Predicate<T>): Stream<T>` --> returns a stream which only contains the elements which fulfill with the Predicate.
   - `distinct(): Stream<T>` --> returns a stream with no duplicate elements. It depends on the implementation of `equals(Object):boolean`.
   - `limit(long): Stream<T>` --> returns a stream whose size is equal or smaller to the parameter.
   - `skip(long): Stream<T>` --> returns a stream which removes the first N elements (parameter). If the size is smaller than the parameter, an empty stream is returned.

- Mapping methods:
   - `map(Function<T, R>): Stream<R>` --> returns a stream which contains the result of applying the parameter function to all elements of the stream. It turns T elements into R elements.
   - `mapToDouble(ToDoubleFunction<T>): DoubleStream` (primitive version).
   - `mapToInt(ToIntFunction<T>): IntStream` (primitive version).
   - `mapToLong(ToLongFunction<T>): LongStream` (primitive version).
   - `flatMap(Function<T, Stream<R>>): Stream<R>` --> it allows to turn each element into a stream and to concatenate all of them in just a final stream.
   - `flatMapToDouble(Function<T, DoubleStream>): DoubleStream` (primitive version).
   - `flatMapToInt(Function<T, IntStream>): IntStream` (primitive version).
   - `flatMapToLong(Function<T, LongStream>): LongStream` (primitive version).
  
- Reduction methods:
   - `count(): long` --> returns the number of elements of the stream.
   - `max(Comparator<T>): Optional<T>` --> returns the maximum element of the stream based on the parameter comparator.  
   - `min(Comparator<T>): Optional<T>` --> returns the minimum element of the stream based on the parameter comparator.
   - `allMatch(Predicate<T>): boolean` --> it verifies if all of the elements of the stream meet the parameter Predicate. If not, it stops the verification and returns false.
   - `anyMatch(Predicate<T>): boolean` --> it verifies if an element of the stream meets the parameter Predicate. If so (only one), it stops the verification and returns true.
   - `noneMatch(Predicate<T>): boolean` --> the opposite of allMatch.
   - `findAny(): Optional<T>` --> returns some element of the stream. It returns an optional.
   - `findFirst(): Optional<T>` --> returns the first element of the stream. It returns an optional.
   - `reduce(BinaryOperator<T>): Optional<T>` --> it reduces the stream using an associative function. It returns an optional.
     - `Optional<Integer> opt = numbers.stream().filter(x -> x % 2 == 0).reduce(Integer::max);`
  - `reduce(t, BinaryOperator<T>): T` --> it execute the reduction of the stream using an initial value and an associative function.
    - `Integer sum = numbers.stream().reduce(0, (subtotal element) -> subtotal + element);`
  - `collect(?): ?` --> final operation which allows to collect the elements of a Stream. Collectors is a class which provides static methods which return the most used collectors. Collectors can be of three types:
       - Reduction and summary: reduce the stream and allow to get aggregate values.
         - `int sum = numbers.stream().collect(summingInt(x -> x.intValue())); //summingInt belongs to Collectors class`
    - Grouping: group elements in a Map using a clasification function.
      - `IntSummaryStatistics res = numbers.stream().collect(summarizintInt(Integer::intValue));`
    - Allocation: grouping where the classification function is a Predicate. It groups the elements in a Map of 2 keys: true and false.
      - `String csv = numbers.stream().map(Object::toString).collect(joinning(", "));`

- Debug methods: an intermediate method which allows to debug.
   - `peek(Consumer<T>): Stream<T>`
     - `List<String> unique = words.stream().flatMap(w -> Stream.of(w.split(" "))).peek(s -> s). map(String::lowerCase).distinct().collect(Collectors.toList());`