# INTRODUCTION

Java 8 introduced a significant set of new features and enhancements that revolutionized the Java programming language. Some of the notable features include:
- Lambdas Expressions: Lambda expressions enable you to write compact and functional-style code. They provide a concise way to represent one method interface using an expression. 
- Functional Interfaces: Functional interfaces are interfaces that have exactly one abstract method and can be used as target types for lambda expressions. 
- Streams API: The Streams API introduced a new abstraction called streams, which allows you to process sequences of elements (such as collections) in a functional and parallel way. 
- Default Methods: Default methods enable you to add new methods to interfaces without breaking the classes that implement those interfaces. This was introduced to support backward compatibility.  
- New Date and Time API: The new Date and Time API (java.time) addresses many of the shortcomings of the previous java.util.Date and java.util.Calendar classes. It offers better handling of dates, times, time zones, and durations. 
- Optional: The Optional class provides a type-level solution for representing optional values and helps to avoid null pointer exceptions.  
- Static Methods in Interfaces: Java 8 allows interfaces to have static methods with implementations. This makes it easier to define utility methods directly in interfaces. 
- Parallel Array Sorting: The Arrays class introduced new methods for parallel sorting of arrays, utilizing multiple cores for improved performance. 
- IO Enhancements: Java 8 introduced the java.util.stream package, which provides classes to work with I/O operations on streams of data, such as reading and writing bytes, characters, and objects. 
- Collectors: The java.util.stream.Collectors class provides a set of built-in collectors for common reduction operations, such as converting elements to lists, sets, or maps. 
- Base64 Encoding and Decoding: Java 8 included the java.util.Base64 class for encoding and decoding Base64-encoded data.

## Lambda expressions
A lambda expression has the following syntax:

```java
(parameters) -> expression
```

Here, parameters are the input parameters of the method, and expression is the body of the method. Lambda expressions can be used wherever a functional interface is expected.

### Lambda expressions features
The following are features of lambda expressions:
- A lambda expression can have zero, one or more parameters.
```java
(x, y) -> x + y
(x, y, z) -> x + y + z
```

- Multiple parameters are enclosed in mandatory parentheses and separated by commas. Empty parentheses are used to represent an empty set of parameters.
```java
(a, b) -> expression
() -> expression
```

- When there is a single parameter, if its type is inferred, it is not mandatory to use parentheses.
```java
a -> return a * a;
```

- The body of the lambda expressions can contain zero, one or more statements. If the body of lambda expression has a single statement curly brackets are not mandatory and the return type of the anonymous function is the same as that of the body expression. When there is more than one statement in the body then these must be enclosed in curly brackets.
```java
(parameters) -> statement;
(parameters) -> { 
    statement1;
    statement2;
    ...
    statementN;
}
```

- The type of the parameters can be explicitly declared or it can be inferred from the context.
- A lambda expression cannot have a throws clause. It is inferred from the context of its use and its body.
- Bytecode generated by a lambda expression is not equivalent to the one generated for an anonymous class. For lambdas, compiler uses invoke_dynamic which has, among other things, better performance
- A lambda is not the same as a closure.
- They are really important because it makes easier to use higher order methods.
- What other thing can we do with methods that accept functions as parameters? Monads.
- A lambda expression can be used to create an instance of a functional interface.
- The type of the functional interface is deduced according to the context and it works both assignment contexts and method invocations (parameters).
- Compiler deduces the type of the lambda expression parameters based on functional interface abstract method definition, so there is no need to write its type.
- To deduce a lambda expression type:
  - Context identification: assignment or method invocation.
  - To identify target type: variable or parameter.
  - To identify functional interface of the target type.
  - To identify the descriptor of the function.
  - To verify that function descriptor is coherent with lambda expression.
  - There are two special cases:
    - The same lambda expression can suit different function descriptors, I mean, different functional interfaces.
    - Compatibility rule for not return. If a lambda expression is made by a sentence, then is compatible with descriptors of functions which don't have any return, I mean, void.
- Lambda expressions can use variables or parameters defined like constants (final) of really constants (a variable or parameter really constant is the one which is assigned just once, even if it hasn't been defined using final).
- In contrast to anonymous classes, in lambdas "this" refers to the class instance where lambda expression has been written.

Lambda expressions enable many benefits of functional programming to Java. Like most OOP languages, Java is built around classes and objects and treats only the classes as their first-class citizens. The other important programming entities, such as functions, take the back seat.  But in functional programming, we can define functions, give them reference variables, and pass them as method arguments and much more.  Note that we were able to do everything prior to Java 8 using anonymous classes that we can do with lambda expressions, but they use a very concise syntax to achieve the same result. Let us see the comparison of the same method implementation using both techniques.

```java
//Using lambda expression
Operator<Integer> addOperation = (a, b) -> a + b;

//Using anonymous class
Operator<Integer> addOperation = new Operator<Integer>() {
    @Override
    public Integer process(Integer a, Integer b) {
        return a + b;
    }
};
```

### Method references
Method references are a special type of lambda expressions. They're often used to create simple lambda expressions by referencing existing methods.  There are four kinds of method references:
- Static methods
- Instance methods of particular objects
- Instance methods of an arbitrary object of a particular type
- Constructor

Let's see the following examples:
```java
Person {
    private String name;
    private LocalDate birthday;
    //getters ... setters ...
    public static int compareByAge(Person a, Person b) {
        return a.birthday.compareTo(b.birthday);
    }
}
```

- Static class method:
```java
Person[] personArray = new Person[1000];
...
//Order an array using lambdas
Arrays.sort(personArray, (a, b) -> Person.compareByAge(a, b));
//Order an array using reference methods
Arrays.sort(personArray, Person::compareByAge);
```

- Instance method:
```java
Person[] personArray = new Person[1000];
...
ComparisonProvider comparisonProvider = new ComparisonProvider();
//Order an array using lambdas
Arrays.sort(personArray, (a, b) -> comparisonProvider.compareByAge(a, b));
//Order an array using reference methods
Arrays.sort(personArray, comparisonProvider::compareByAge);
```

- Type method:
```java
String[] strings = {"asdf", "asdfas", ...};
//Order an array using lambdas
Arrays.sort(strings, (a, b) -> a.compareToIgnoreCase(b));
//Order an array using reference methods
Arrays.sort(strings, String::compareToIgnoreCase);
```

- Constructor (with no parameters):
```java
//Create a person using lambdas
Supplier<Persona> s1 = () -> new Persona();
Persona p1 = s1.get();
//Create a person using reference methods
Supplier<Persona> s1 = Persona::new;
Persona p1 = s1.get();  
```

- Constructor (with parameters):
```java
//Create a person using lambdas
Function<String, Persona> f1 = (w) -> new Persona(w);
Persona p1 = f1.apply("Manu");
//Create a person using reference methods
Function<String, Persona> f1 = Persona::new;
Persona p1 = f1.apply("Manu");
```

### Lambda structure recap
- Parameters are separated of the function body by "->".
- Parameters are separated by "," and between "(" and ")" (optional when there is only one parameter).
- Parameter type can be omitted when there is enough information for the compiler to deduce it.
- If the function body is complex (it has more than one line) it must be between "{" and "}", to have ";" and to have a "return".
- If the function body is simple you can omit "{", "}", ";" and "return".
- If the lambda expression only calls a unique method we can use a reference to a method. The reference methods are the invocation of methods by its name. Lambda expressions compacter and easier to read:
  - To refer to a static class method: Class:staticMethodName
  - To refer to an object method: Object::instanceMethodName
  - To refer to an arbitrary object method of a concrete type: Type::methodName
  - To refer to a constructor: Class::new

## Functional interfaces
Functional interfaces are interfaces that have exactly one abstract method. Lambda expressions are often used to implement these interfaces in a more concise manner.  For example, the Runnable interface is a functional interface with a single abstract method run(). The following is an example of functional interface:

```java
@FunctionalInterface
interface MyFunctionalInterface {
    void performAction();
}
```

The @FunctionalInterface annotation is optional, but using it explicitly indicates your intention to create a functional interface. It also helps the compiler catch accidental additions of new abstract methods.

Java provides several built-in functional interfaces in the java.util.function package that cover a wide range of use cases:
- Consumer<T>: Accepts an argument of type T and performs an action without returning a result.
- BiConsumer<T, U>: Accepts two arguments of type T and U and performs an action without returning a result.
- Supplier<T>: Supplies a result of type T without taking any input. 
- Predicate<T>: Evaluates a condition on an input of type T and returns a boolean result. 
- Function<T, R>: Takes an input of type T and returns a result of type R.

### Benefits of functional interfaces
- Expressive Code: Functional interfaces enable concise and expressive code with lambda expressions and method references. 
- Modularity: Functional interfaces promote modular design by encapsulating specific behavior within a single interface. 
- Readability: Clear method contracts in functional interfaces enhance code readability and maintainability. 
- Functional Programming: Functional interfaces facilitate the adoption of functional programming concepts in Java.

## Streams API
The Java Streams API, introduced in Java 8, revolutionized the way we process collections and data in a functional and declarative style. Streams provide a powerful toolset for performing operations on sequences of elements, such as collections or arrays, while abstracting away the underlying implementation details.

Simply put, streams are wrappers around a data source, allowing us to operate with that data source and making bulk processing convenient and fast. A stream does not store data and, in that sense, is not a data structure. It also never modifies the underlying data source. This functionality – java.util.stream – supports functional-style operations on streams of elements, such as map-reduce transformations on collections.
- A stream is NOT a collection of elements (its content can not be saved in any place).
- A stream is NOT a sequence (the order can be or not important).
- A stream is an abstraction that represents zero or more values (a value means an immutable object, which is extremely important to concurrency).
- Immutability is essential in functional programming.
- A stream is like a strengthened iterator.
- Streams make pretty pipeline concept. A pipeline is a sequence of zero or more intermediate operations and a final operation with a stream.
Pipelines are lazy: job is made just when a final operation is found. If there isn't a final operation, the stream do nothing.
- It exists some primitive streams: DoubleStream, IntStream and LongStream (it prevent from using Autoboxing and Unboxing).
- Streams use Filter pattern --> Map (to map to other type) --> Reduce (return a unique value).

Streams have two different type of operations:
- Terminal operation: after the operation is performed, the stream pipeline is considered consumed, and can no longer be used.
- Intermediate operation: return a new stream on which further processing can be done.

A stream pipeline consists of a stream source, followed by zero or more intermediate operations, and a terminal operation.

As mentioned before, one of the most important characteristics of Java streams is that they allow for significant optimizations through lazy evaluations. Computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed. All intermediate operations are lazy, so they’re not executed until a result of a processing is actually needed. Let's see with the following example how important this is:

```java
Integer[] empIds = { 1, 2, 3, 4 };
    
Employee employee = Stream.of(empIds)
  .map(employeeRepository::findById)
  .filter(e -> e != null)
  .filter(e -> e.getSalary() > 100000)
  .findFirst()
  .orElse(null);

assertEquals(employee.getSalary(), new Double(200000));
```

Since the array has 4 elements, we could think the findById method is called 4 times. However, since streams are allow lazy evaluations and they don't get executed until a terminal operation comes in:
1. findById is called with id = 1.
2. Let's assume an employee with that id exists in the database, then flow evaluates the next call.
3. Let's assume that employee does not make more than 100000. Then flow finishes (lazy evaluation) and goes to the next element.
4. findById is called with id = 2.
5. Let's assume an employee with that id exists in the database, then flow evaluates the next call.
6. Let's assume that employee makes more than 100000. The flow evaluates the next call.
7. Since findFirst is a terminal operation, the flows end here and the function findById has been called only twice.

### Stream operations
#### Basic methods:
- `static <T> of(T... values): Stream<T>` --> returns a sequential ordered stream whose elements are the specified values.
- `static <T> of(T t): Stream<T>` --> returns a sequential Stream containing a single element.
- `static <T> empty():  Stream<T>` --> returns an empty stream.
- `static <T> of(T[]): Stream<T>` --> returns a stream of the array given as a parameter. Primitive version returns DoubleStream, IntStream, LongStream.
- `Collection<E>.stream(): Stream<E>` --> Returns a stream of the elements of the collection. Parallel version: `Collection<E>.parallelStream(): Stream<E>`.
- `static <T> generate(Supplier<T>): Stream<T>` --> returns and infinite stream, sequential but not ordered, from a lambda expression provided by the supplier.
- `static <T> builder(): Stream.Builder<T>` --> returns a builder for a Stream.
- `static <T> concat(Stream<? extends T>, Stream<? extends T>): Stream<T>` --> creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.
- `static <T> iterate(T, UnaryOperation<T>): Stream<T>` --> Returns an infinite stream, ordered and sequential, from the initial value T and from applying the UnaryOperator function to the initial value to get the other elements. To limit its size, the method `+limit(long): Stream` can be used.

#### Iteration methods:
- `forEach(Consumer<? super T> action): void` --> performs an action for each element of this stream.
  - Terminal operation.
- `forEachOrdered(Consumer<? super T> action): void` --> performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order.
  - Terminal operation.

#### Filter methods:
All filter methods are intermediate:
- `filter(Predicate<T>): Stream<T>` --> returns a stream which only contains the elements which fulfill with the Predicate.
- `distinct(): Stream<T>` --> returns a stream with no duplicate elements. It depends on the implementation of `equals(Object):boolean`.
- `limit(long): Stream<T>` --> returns a stream whose size is equal or smaller to the parameter.
- `skip(long): Stream<T>` --> returns a stream which removes the first N elements (parameter). If the size is smaller than the parameter, an empty stream is returned.

#### Order methods
- `sorted(): Stream<T>` --> returns a stream consisting of the elements of this stream, sorted according to natural order.
  - Intermediate operation.
- `sorted(Comparator<? super T>): Stream<T>` --> returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.
  - Intermediate operation.

#### Mapping methods:
All mapping methods are intermediate:
- `<R> map(Function<? super T,? extends R>): Stream<R>` --> returns a stream which contains the result of applying the parameter function to all elements of the stream. It turns T elements into R elements.
- `mapToDouble(ToDoubleFunction<? super T>): DoubleStream` (primitive version).
- `mapToInt(ToIntFunction<? super T>): IntStream` (primitive version).
- `mapToLong(ToLongFunction<? super T>): LongStream` (primitive version).
- `<R> flatMap(Function<? super T,? extends Stream<? extends R>>): Stream<R>` --> returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. The main difference between map() and flatMap() is that flatMap() method first flattens the input Stream of Streams to a Stream of Objects. Thereafter, it works similarly to the map() method.
- `flatMapToDouble(Function<? super T,? extends DoubleStream>): DoubleStream` (primitive version).
- `flatMapToInt(Function<? super T,? extends IntStream>): IntStream` (primitive version).
- `flatMapToLong(Function<? super T,? extends LongStream>): LongStream` (primitive version).

#### Reduction methods:
All reduction methods are terminal:
- `count(): long` --> returns the number of elements of the stream.
- `max(Comparator<? super T>): Optional<T>` --> returns the maximum element of the stream based on the parameter comparator.
- `min(Comparator<? super T>): Optional<T>` --> returns the minimum element of the stream based on the parameter comparator.
- `allMatch(Predicate<? super T>): boolean` --> it verifies if all of the elements of the stream meet the parameter Predicate. If not, it stops the verification and returns false.
- `anyMatch(Predicate<? super T>): boolean` --> it verifies if an element of the stream meets the parameter Predicate. If so (only one), it stops the verification and returns true.
- `noneMatch(Predicate<? super T>): boolean` --> the opposite of allMatch.
- `findAny(): Optional<T>` --> returns some element of the stream. It returns an optional.
- `findFirst(): Optional<T>` --> returns the first element of the stream. It returns an optional.
- `reduce(BinaryOperator<T>): Optional<T>` --> it reduces the stream using an associative function. It returns an optional.
  - `Optional<Integer> opt = numbers.stream().filter(x -> x % 2 == 0).reduce(Integer::max);`
- `reduce(T identity, BinaryOperator<T> combiner): T` --> it executes the reduction of the stream using an initial value and an associative function.
  - `Integer sum = numbers.stream().reduce(0, (subtotal, element) -> subtotal + element);`
- `reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner): <U> U` --> performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions.`
  - Combiner is used for parallel execution. Combiner combines the results of all sub-streams that run parallel.
- `collect(Collector<? super T,A,R> collector): <R,A> R` --> performs a mutable reduction operation on the elements of this stream using a Collector.
- `collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner): <R> R` --> performs a mutable reduction operation on the elements of this stream.
  - Reduction and summary: reduce the stream and allow to get aggregate values.
    - `int sum = numbers.stream().collect(summingInt(x -> x.intValue())); //summingInt belongs to Collectors class`
  - Grouping: group elements in a Map using a clasification function.
    - `IntSummaryStatistics res = numbers.stream().collect(summarizintInt(Integer::intValue));`
  - Allocation: grouping where the classification function is a Predicate. It groups the elements in a Map of 2 keys: true and false.
    - `String csv = numbers.stream().map(Object::toString).collect(joinning(", "));`
- `toArray(): Object[]` --> returns an array containing the elements of this stream.
  - Terminal operation.
- `toArray(IntFunction<A[]> generator): <A> A[]` --> returns an array containing the elements of this stream, using the provided generator function to allocate the returned array, as well as any additional arrays that might be required for a partitioned execution or for resizing.
  - Terminal operation.

#### Debug methods: an intermediate method which allows to debug.
- `peek(Consumer<? super T>): Stream<T>` --> returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.
  - Intermediate operation.
  - `List<String> unique = words.stream().flatMap(w -> Stream.of(w.split(" "))).peek(s -> s). map(String::lowerCase).distinct().collect(Collectors.toList());`


There are several methods inherited from BaseStream:
```java
- void --> close(): closes this stream, causing all close handlers for this stream pipeline to be called.
  - Terminal operation.
- boolean --> isParallel(): returns whether this stream, if a terminal operation were to be executed, would execute in parallel.
  - Terminal operation.
- Iterator<T> --> iterator(): returns an iterator for the elements of this stream.
  - Terminal operation.
- S --> onClose(Runnable closeHandler): returns an equivalent stream with an additional close handler.
  - Intermediate operation.
- S --> parallel(): returns an equivalent stream that is parallel.
  - Intermediate operation.
- S --> sequential(): returns an equivalent stream that is sequential.
  - Intermediate operation.
- Spliterator<T> --> spliterator(): returns a spliterator for the elements of this stream.
  - Terminal operation.
- S --> unordered(): returns an equivalent stream that is unordered.
  - Intermediate operation.
```

### Collectors
Collectors are a crucial part of the Stream API, that facilitate the process of transforming the elements of a stream into various data structures or performing aggregation operations. Collectors encapsulate the logic for accumulating elements from a stream into a mutable container (such as a collection or a string), often including filtering, mapping, and reduction operations. They allow you to efficiently perform operations on streams and collect the results into a desired format.

Collectors are defined by the java.util.stream.Collectors class and provide a set of methods for creating common collectors. They are used in the collect terminal operation of the Stream API.

The Collectors class offers a variety of methods to create collectors for different purposes. Some of the commonly used methods include:
- toList(): Collects stream elements into a List. 
- toSet(): Collects stream elements into a Set. 
- toMap(keyMapper, valueMapper): Collects stream elements into a Map where each element is transformed into a key-value pair using the provided key and value mappers. 
- joining(): Collects stream elements into a single String by concatenating them using a delimiter. 
- groupingBy(classifier): Collects elements into a Map where keys are determined by the provided classifier function. 
- partitioningBy(predicate): Collects elements into a Map where keys are true or false based on whether they satisfy the provided predicate.

## Default methods
Default methods are methods added to interfaces with a default implementation. They provide a way to extend the functionality of an existing interface without breaking the classes that already implement it.

Before Java 8, adding new methods to an interface would require modifying all classes that implement that interface. This was impractical for widely used interfaces like Collection. Default methods address this issue by allowing interface developers to provide a default implementation that can be optionally overridden by implementing classes.

A default method is defined in an interface using the default keyword before the method signature. Here's the syntax:
```java
public interface MyInterface {
    // Abstract method
    void myAbstractMethod();

    // Default method
    default void myDefaultMethod() {
        // Default implementation
    }
}
```

### Using default methods
Implementing classes can choose whether to override a default method or use the provided implementation. If a class does not override a default method, it inherits the default implementation from the interface.

When a class implements two interfaces that both have a default method with the same signature, the diamond inheritance problem arises. Java resolves this by requiring the implementing class to provide its own implementation or override the default method.

### Benefits of default methods
- Backward Compatibility: default methods enable adding new methods to existing interfaces without breaking the code in implementing classes. This maintains backward compatibility. 
- Extending Interface Functionality: default methods make it possible to extend the functionality of interfaces over time without requiring changes to existing implementations. 
- Avoiding Code Duplication: default methods help avoid code duplication by allowing multiple interfaces to share common method implementations.

### When to use default methods
- Adding New Methods to Existing Interfaces: use default methods when you want to add new methods to an existing interface without forcing all implementing classes to provide implementations immediately. 
- Providing Default Implementations for Optional Methods: use default methods when you have optional methods in an interface that provide useful, but non-essential, functionality.

## New Date and Time API
Java 8 introduced new APIs for Date and Time to address the shortcomings of the older java.util.Date and java.util.Calendar. There some issues with the existing Date/Time APIs:
- Thread safety – The Date and Calendar classes are not thread safe, leaving developers to deal with the headache of hard-to-debug concurrency issues and to write additional code to handle thread safety. On the contrary, the new Date and Time APIs introduced in Java 8 are immutable and thread safe, thus taking that concurrency headache away from developers. 
- API design and ease of understanding – The Date and Calendar APIs are poorly designed with inadequate methods to perform day-to-day operations. The new Date/Time API is ISO-centric and follows consistent domain models for date, time, duration and periods. There are a wide variety of utility methods that support the most common operations. 
- ZonedDate and Time – Developers had to write additional logic to handle time-zone logic with the old APIs, whereas with the new APIs, handling of time zone can be done with Local and ZonedDate/Time APIs.

### LocalDate, LocalTime and LocalDateTime
The most commonly used classes are LocalDate, LocalTime and LocalDateTime. As their names indicate, they represent the local date/time from the context of the observer. We mainly use these classes when time zones are not required to be explicitly specified in the context.

#### LocalDate
The LocalDate represents a date in ISO format (yyyy-MM-dd) without time:
```java
LocalDate localDate = LocalDate.now();
```

And we can get the LocalDate representing a specific day, month and year by using the of method or the parse method:
```java
LocalDate.of(2015, 02, 20);
LocalDate.parse("2015-02-20");
```

The LocalDate provides different utility methods:
```java
LocalDate tomorrow = LocalDate.now().plusDays(1);
LocalDate previousMonthSameDay = LocalDate.now().minus(1, ChronoUnit.MONTHS);
DayOfWeek sunday = LocalDate.parse("2016-06-12").getDayOfWeek();
int twelve = LocalDate.parse("2016-06-12").getDayOfMonth();
boolean leapYear = LocalDate.now().isLeapYear();
boolean notBefore = LocalDate.parse("2016-06-12").isBefore(LocalDate.parse("2016-06-11"));
boolean isAfter = LocalDate.parse("2016-06-12").isAfter(LocalDate.parse("2016-06-11"));

LocalDateTime beginningOfDay = LocalDate.parse("2016-06-12").atStartOfDay();
LocalDate firstDayOfMonth = LocalDate.parse("2016-06-12").with(TemporalAdjusters.firstDayOfMonth());
```

#### LocalTime
The LocalTime represents time without a date.
```java
LocalTime now = LocalTime.now();
LocalTime sixThirty = LocalTime.parse("06:30");
LocalTime sixThirty = LocalTime.of(6, 30);
LocalTime sevenThirty = LocalTime.parse("06:30").plus(1, ChronoUnit.HOURS);
int six = LocalTime.parse("06:30").getHour();
boolean isbefore = LocalTime.parse("06:30").isBefore(LocalTime.parse("07:30"));
LocalTime maxTime = LocalTime.MAX
```

#### LocalDateTime
LocalDateTime is used to represent a combination of date and time. This is the most commonly used class when we need a combination of date and time.
```java
LocalDateTime.now();
LocalDateTime.of(2015, Month.FEBRUARY, 20, 06, 30);
LocalDateTime.parse("2015-02-20T06:30:00"); //yyyy-MM-ddThh:mm:ss
localDateTime.plusDays(1);
localDateTime.minusHours(2);
localDateTime.getMonth();
```

#### ZonedDateTime
Java 8 provides ZonedDateTime when we need to deal with time-zone-specific date and time. The ZoneId is an identifier used to represent different zones. There are about 40 different time zones.

```java
ZoneId zoneId = ZoneId.of("Europe/Paris");
Set<String> allZoneIds = ZoneId.getAvailableZoneIds();
ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, zoneId);
ZonedDateTime.parse("2015-05-03T10:15:30+01:00[Europe/Paris]");
LocalDateTime localDateTime = LocalDateTime.of(2015, Month.FEBRUARY, 20, 06, 30);
        ZoneOffset offset = ZoneOffset.of("+02:00");
        OffsetDateTime offSetByTwo = OffsetDateTime.of(localDateTime, offset); //We now have a localDateTime of 2015-02-20 06:30 +02:00.
```

#### Period
The Period class is widely used to modify values of given a date or to obtain the difference between two dates:
```java
LocalDate initialDate = LocalDate.parse("2007-05-10");
LocalDate finalDate = initialDate.plus(Period.ofDays(5));
int five = Period.between(initialDate, finalDate).getDays();
long five = ChronoUnit.DAYS.between(initialDate, finalDate);
```

#### Duration
Similar to Period, the Duration class is used to deal with Time.
```java
LocalTime initialTime = LocalTime.of(6, 30, 0);
LocalTime finalTime = initialTime.plus(Duration.ofSeconds(30));
long thirty = Duration.between(initialTime, finalTime).getSeconds();
long thirty = ChronoUnit.SECONDS.between(initialTime, finalTime);
```

#### Compatibility with Date and Calendar
Java 8 has added the toInstant() method, which helps to convert existing Date and Calendar instance to new Date and Time API:
```java
LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
LocalDateTime.ofInstant(calendar.toInstant(), ZoneId.systemDefault());
```

The LocalDateTime can be constructed from epoch seconds. The result of the below code would be a LocalDateTime representing 2016-06-13T11:34:50:
```java
LocalDateTime.ofEpochSecond(1465817690, 0, ZoneOffset.UTC);
```

#### Date and Time formatting
Java 8 provides APIs for the easy formatting of Date and Time:
```java
LocalDateTime localDateTime = LocalDateTime.of(2015, Month.JANUARY, 25, 6, 30);
String localDateString = localDateTime.format(DateTimeFormatter.ISO_DATE); //yyyy-MM-dd
localDateTime.format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
localDateTime.format(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).withLocale(Locale.UK)); //dd-MMM-yyyy, hh:mm:ss
```

## Optionals
Java Optionals are a container class that represents an optional value, which can be either a non-null value or a null value. Optionals provide a way to explicitly handle the absence of a value, reducing the chances of null pointer exceptions. Before Optionals, handling null values required manual checks, which often led to verbose and error-prone code. Optionals address this issue by providing a more elegant and safer way to deal with null values.

To create an optional:
```java
Optional<String> presentOptional = Optional.of("Hello");
Optional<String> nullableOptional = Optional.ofNullable(null);
Optional<String> emptyOptional = Optional.empty();
```

To get a value from an optional;
```java
String value = presentOptional.get(); // Throws NoSuchElementException if absent
String valueOrDefault = emptyOptional.orElse("Default Value");
String valueOrSupplier = nullableOptional.orElseGet(() -> "Default Value");
```

Other common operations:
```java
boolean isPresent = presentOptional.isPresent(); //allows you to perform an action if a value is present.
boolean isEmpty = emptyOptional.isEmpty();
presentOptional.ifPresent(val -> System.out.println("Value: " + val));
String value = nullableOptional.orElse("Default Value");
String value = nullableOptional.orElseGet(() -> "Default Value");
String value = presentOptional.orElseThrow(() -> new RuntimeException("Value is absent"));
Optional<Integer> lengthOptional = presentOptional.map(String::length);
Optional<String> combined = nullableOptional.or(() -> presentOptional);
Optional<String> combined = nullableOptional.orElseGet(() -> presentOptional.orElse("Fallback Value"));
```

### Best Practices for Using Optionals
- Using Optionals for Return Types: use Optionals as return types for methods that might not always have a value to return. 
- Avoiding Unnecessary Nesting: avoid nesting Optionals within Optionals. Instead, use methods like flatMap() to perform successive operations. 
- Dealing with Stream Operations and Optionals: convert Optionals to Streams for seamless integration with stream operations.

### When to Use Optionals
- Handling Null Values Safely: use Optionals to handle methods that might return null values, promoting safer code. 
- Return Values and Method Parameters: use Optionals for return values and method parameters where values are optional. 
- Optional as Fields: use Optionals as fields when you have fields that can be optionally initialized.

## Static methods
Static Methods in Interface are those methods, which are defined in the interface with the keyword static. Unlike other methods in Interface, these static methods contain the complete definition of the function and since the definition is complete and the method is static, therefore these methods cannot be overridden or changed in the implementation class.

## Array parallel sorting
Java 8 introduced a new method called as parallelSort() in java.util.Arrays Class. It uses Parallel Sorting of array elements. Parallel sorting uses concept of MultiThreading which makes the sorting faster as compared to normal sorting method.

Algorithm of parallelSort():
- The array is divided into sub-arrays and that sub-arrays is again divided into their sub-arrays, until the minimum level of detail in a set of array.
- Arrays are sorted individually by multiple thread.
- The parallel sort uses Fork/Join Concept for sorting.
- Sorted sub-arrays are then merged.

For sorting data in ascending order:
```java
public static void parallelSort(Object obj[])
```

For sorting data in specified range in ascending order :
```java
public static void parallelSort(Object obj[], int from, int to)
```

## Base 64 coding and encoding
Java 8 adds Base 64 capabilities to the standard API.

## Java I/O Streams
Java I/O streams provide a way to read or write sequences of data, whether they are bytes, characters, or other types, from/to different sources and destinations. Streams abstract the underlying complexity of I/O operations and provide a uniform interface.

There are two main types of streams: byte streams and character streams. Byte streams are suitable for reading and writing raw binary data, while character streams are designed for reading and writing character data with encoding and decoding capabilities.
- Byte streams are used for binary data and are represented by classes such as InputStream and OutputStream.
- Character streams are used for text data and are represented by classes like Reader and Writer.

### Byte streams
The InputStream class hierarchy provides methods to read data from a source, and the OutputStream class hierarchy provides methods to write data to a destination.
- Use InputStream subclasses like FileInputStream to read data from sources like files. Reading can be done using methods like read(), read(byte[]), or read(byte[], int, int).
- Use OutputStream subclasses like FileOutputStream to write data to destinations like files. Writing can be done using methods like write(int), write(byte[]), or write(byte[], int, int).

### Character streams
The Reader class hierarchy provides methods to read character data from sources, and the Writer class hierarchy provides methods to write character data to destinations.
- Use Reader subclasses like FileReader to read character data from sources like files. Reading can be done using methods like read(), read(char[]), or read(char[], int, int).
- Use Writer subclasses like FileWriter to write character data to destinations like files. Writing can be done using methods like write(int), write(char[]), or write(char[], int, int).

### Buffered streams
Buffered streams, such as BufferedReader and BufferedWriter, provide better performance by reading/writing data in larger chunks and reducing the number of direct I/O operations.
- Use BufferedReader for reading character data with a buffer, which improves efficiency.
- BufferedWriter is used for writing character data with buffering.

### File I/O
Use byte or character streams to read and write data from/to files. Always ensure proper resource closing using the try-with-resources statement.

### Byte Array Streams
Byte array streams allow you to read/write data from/to in-memory byte arrays.
- ByteArrayInputStream reads data from a byte array.
- ByteArrayOutputStream writes data to a byte array.

### Object Serialization
Object serialization allows you to save and restore Java objects to/from streams.
- ObjectInputStream reads objects.
- ObjectOutputStream writes objects.

Serialization is used for converting objects into a binary format, making them suitable for storage or transmission. Deserialization is the process of converting the binary representation back to an object.

### Closing Streams and Resources
Always close streams and resources to release system resources and avoid memory leaks. The try-with-resources statement ensures that resources are closed automatically when they are no longer needed, reducing the risk of resource leaks.

### Best Practices for I/O
- Proper Resource Management: always close streams and resources using the try-with-resources statement to ensure proper resource management. 
- Using Buffered Streams: use buffered streams for better I/O performance, especially when reading or writing in small chunks. 
- Avoiding Unnecessary I/O Operations: minimize the number of I/O operations to improve performance, especially when reading/writing large amounts of data.